
//⠀⠀⠀     ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡠⠂⠠⣦⢶⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣤⠤⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⡧⠯⠁⠘⣽⡿⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡟⠠⢶⣶⣿⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣴⡛⣩⣵⡂⠀⢐⡒⡆⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡇⠀⠨⣵⣻⣧⣽⣳⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⢸⡿⣞⡿⣋⡄⠀⠀⢭⣑⢻⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠸⡇⠀⠀⠔⠫⣿⣿⣿⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⣸⣾⣧⣶⠟⡋⣀⡀⠀⢀⣀⣯⢎⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣷⠀⠀⠠⢶⣶⣞⣻⢿⣾⣿⣷⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣈⣾⣫⣿⣽⣶⣯⣟⡶⠄⠀⠀⠲⠄⢧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⡆⠀⣴⣓⠚⠛⣿⣿⣿⣾⣿⣿⣷⣤⡀⠀⠀⠀⠀⠀⠀⠀⠀⣀⣀⣀⣀⣀⣀⣀⣀⣀⡀⠀⠀⠀⠀⣠⣾⣿⣿⣿⣿⣿⣿⡿⠟⠉⠁⠀⠀⠀⠂⡧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⡀⠉⠉⠉⣳⣿⣶⣿⣿⣿⣿⣿⣿⣿⣷⡶⣴⣴⣶⡛⠛⠉⠉⠉⠉⠉⠀⢠⠛⠛⢿⣟⣯⣷⣾⣿⣿⣿⣿⣿⣿⣟⣛⣭⡴⠄⠀⠀⠀⠀⠈⠆⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⡧⠀⠀⠈⢉⣉⣿⣿⣿⣿⣿⠿⣛⣿⡿⠀⠀⠀⠻⢿⣦⢀⣀⡀⠀⠀⣤⣇⣀⣼⡞⠈⠉⠉⠉⣀⠉⠛⠻⢿⣿⣿⣟⠓⣦⠔⠀⠀⠀⠀⠀⠨⡕⠅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣇⠀⣤⣬⣿⣿⠟⠛⠉⠁⠀⠘⣿⣿⠇⠀⠀⠑⠀⠘⠿⠟⠛⠙⠦⡞⠉⠛⠾⠃⠀⠀⠀⠀⠀⢿⣿⣧⠀⠀⠀⠈⠙⢷⣶⣼⡒⠓⠂⠀⢀⠀⠍⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣾⠿⠛⠉⠀⠀⠀⠀⠀⠀⠀⠘⠿⠀⠀⣀⠊⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⠾⡿⠉⠀⠀⠀⠀⠀⠀⠙⠿⣿⣶⡄⠀⢸⡇⡆⠀⠐⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠏⠉⢀⣰⣷⡿⠷⣾⣶⣶⣤⣀⠀⠀⠀⠀⠹⢦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡰⠈⠀⠀⠀⠁⣀⣤⣶⣾⣽⣿⣷⣤⣄⠀⠉⠛⣧⣿⠽⡀⡅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡾⠥⠤⠴⣾⡿⠃⢠⣾⣿⡟⠉⠉⣻⡗⢄⠀⠀⠀⠈⠣⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣾⠁⠀⠀⡴⡏⠎⢿⣿⠋⠐⢿⣿⣏⠈⢹⣦⠀⠀⠀⢹⡙⠟⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⢏⠀⠀⠀⠀⢿⣇⠀⢸⣿⣿⣧⣀⣰⣿⡇⠀⣧⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡇⠀⠀⠀⡈⡇⠀⡀⢸⣦⣤⡀⣼⣿⢿⠀⠀⢀⠈⠁⠀⠣⣄⠘⣳⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡼⠃⠀⠁⠄⡀⠀⠀⠛⠦⠌⠿⠿⢿⠿⠿⠋⣠⣾⣿⡀⢀⡤⠖⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠀⢸⣿⣄⡀⠈⠻⢿⢿⠿⡿⠁⣀⡸⠃⠀⠀⠀⣠⠀⠻⢮⢥⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⠁⠀⠀⠀⠀⠀⠀⠃⠰⠠⢄⡀⠀⠀⠀⠀⠀⠀⠀⣨⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠿⣷⣜⠋⠉⠉⠉⠉⠓⠀⠐⠀⠈⠈⠄⠀⡄⠐⠈⠁⠁⠀⡁⠂⠁⠘⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣠⠏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠐⠒⠠⢀⠠⢺⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⢷⣦⡀⠀⠄⠀⠤⠀⠀⠐⠀⠉⠀⠀⠀⠀⠀⠀⠀⠄⠀⠀⢀⢀⡑⠝⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢠⡏⠀⣠⣤⣠⣀⡀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠛⠀⠀⠀⠀⣀⣤⣤⣤⣦⣤⣤⣤⣤⣤⣤⣤⣤⣀⠀⠀⠀⠀⠙⠛⠠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡠⠀⢰⣄⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⠀⢈⣭⣿⠷⠚⠛⠙⢹⣇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢿⣿⣿⣿⣿⣿⣽⣿⣻⣟⣿⣽⣻⣟⣿⡷⠀⠀⠀⠀⠀⠐⢡⢀⠀⠀⠀⠀⠀⢀⣶⣴⣦⣤⣤⣄⡀⠀⢀⣶⡧⡆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣧⠀⠀⠈⠁⠀⠀⠀⠀⢸⣿⡆⠀⠀⠶⠆⢾⠃⠀⠷⠀⠀⠀⠀⠀⠈⠉⠉⢿⣟⣿⣿⣽⣿⡾⣿⡅⠀⠀⠀⠀⠀⠀⠀⢠⡄⢠⢯⠐⣀⠀⢀⣀⡈⠉⠉⠙⠙⠛⠛⠳⢚⡾⣽⡋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⡇⠀⠀⢀⡀⢠⣶⠀⣴⡄⠀⠀⠀⠀⠀⠀⠀⠙⢯⣿⣾⣿⣏⡿⠃⠀⠀⠀⠀⠀⠀⠀⠠⣄⠠⣠⣀⡀⡈⠉⠉⠀⠀⠀⠀⠀⠀⢀⣤⡖⣿⠁⠴⣾⡅⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢧⠀⠀⠀⠀⠀⠀⠀⠀⠹⠃⠀⠀⠀⡀⠀⢀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠙⢿⡿⠋⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⠀⠉⠐⠀⠀⠀⠀⢠⡴⠞⠋⠁⠀⠀⠀⣠⢂⣥⠡⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢷⣤⣤⠀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣼⣧⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠙⠀⠈⠈⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⣀⠤⢈⡋⠉⠁⠀⠀⠚⠄⠌⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠏⠡⢺⡿⠏⠀⠀⡠⠀⠀⠀⠀⠀⠀⠐⠒⠠⠤⠄⠠⠤⠤⠤⠴⠒⠚⠉⠉⠉⠉⠉⠉⠓⠲⠤⢤⣀⣀⡀⣀⠤⠒⡖⠊⠩⠉⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⠀⠀⠁⢴⡃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣰⠏⠀⠀⠼⣅⠀⠀⢩⢶⣿⣿⣿⣶⠶⠚⠀⠀⠀⠀⠀⠐⠤⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⡄⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡀⡑⠘⡮⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠏⠀⠀⢠⠎⠁⠀⠀⠀⠈⠉⠁⠉⠉⠟⠋⠽⢴⣂⣥⣀⣀⣀⣈⡉⢒⡶⠦⣀⣀⣀⣠⣀⣀⣀⣤⣴⣶⠿⠛⠁⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢬⣿⣡⣗⡅⠤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⡏⠀⠀⠀⠀⠀⢡⠔⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠁⠉⠉⠉⠀⠀⠀⠉⠉⠉⡍⠉⠉⢉⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣄⣹⣿⣿⣖⣹⠨⣏⡐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢷⠀⠀⠀⠀⢰⠃⠤⠊⢠⠴⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⠀⠀⢸⠐⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠤⣄⣤⣄⣹⣿⠛⡓⠂⠀⠙⠀⢻⠬⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣸⣿⣤⠄⠀⠀⠀⠀⣴⠈⠛⢻⢛⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣾⠞⠀⠀⠀⠈⣿⡄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣄⠀⠀⠀⠀⠀⠤⣄⣷⣬⣙⡛⠛⠉⠀⠀⠀⠀⣒⡰⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢰⠃⢼⣿⡇⠀⠀⠀⠀⠈⠁⠀⠟⠉⢩⣭⢉⣠⢀⡤⠀⠀⠀⠀⠀⠀⠀⢀⣾⠇⠀⠀⠀⠀⠀⠀⢀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣔⢆⢸⡀⠀⢀⣰⣠⡿⠒⠂⠈⠀⠁⠀⠀⠀⢀⠈⢠⣳⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣼⡄⠀⠿⢟⡿⣶⡀⠀⠀⠀⠀⠀⠀⠸⠋⠡⣰⢿⣧⣞⣡⣾⣀⣄⣤⡾⠋⠈⠀⠀⠀⠀⠀⠀⠀⠀⢳⡈⢿⣆⣠⣀⢠⢀⡀⢠⣬⣏⣳⣬⠿⠛⠃⠈⠉⠀⠀⠀⠀⠀⠀⠀⠀⡰⣟⣿⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⡀⠀⠈⣼⠥⣿⣧⣶⣾⣀⡀⠀⠀⠀⠀⠁⠘⠁⠐⠛⠁⠘⠉⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠃⠀⠉⠉⠛⠿⠿⠟⢻⣿⠉⠛⠙⠒⠒⠀⠀⠀⠀⠀⠀⠀⠀⢈⣷⣾⣾⣧⣎⡯⠂⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣿⣿⡇⢰⣀⠀⢠⠿⣿⣿⣿⣼⣧⣾⢀⠀⠀⠀⣀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡀⠀⠀⠐⣆⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⣝⠒⢶⣿⡿⢿⡏⠁⠼⠁⡋⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢹⣿⣷⡼⣿⣄⠀⠀⠀⢨⠿⢻⣿⣿⣧⣾⣷⣏⣡⢀⣠⣷⣖⣴⣶⣶⣾⠤⢀⣤⣴⡾⠁⠀⠀⠘⣿⡷⣦⣄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⣀⢰⣶⣀⠰⣿⣷⣾⠏⠉⠀⠸⢦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⣿⣿⣿⢻⠿⠇⡀⠀⠀⠀⠘⠈⠁⠀⡽⠛⠟⠋⣵⣾⡿⠿⠛⡿⠋⠁⡰⢫⢯⢿⠁⠀⠀⠀⠀⠘⠳⣽⣿⣦⢀⣞⣤⡀⠹⣤⣦⠀⡀⢴⢠⠀⢳⣿⣭⣛⠻⠏⠉⠉⠀⠀⠀⡨⢸⠄⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⣟⣾⣿⣷⣿⣧⡄⠀⠀⠀⠀⠀⠀⠀⠀⠒⠚⠉⠀⠀⠈⠀⠀⠊⠀⠀⠉⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠻⣿⢿⡿⣿⡦⣼⣿⡳⣽⣽⣷⠷⢬⠉⠉⠉⠁⠀⠀⠀⠀⠀⠀⢀⡨⣠⠴⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣿⢩⣯⣼⣿⣿⡿⠻⡜⣦⣠⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠃⠀⠀⠀⠈⠙⠋⠉⠉⠋⠁⠀⠀⠀⠀⠀⠀⠀⠀⠀⠠⢀⠐⣤⣼⣿⢩⡏⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠘⡇⣾⣽⣿⣿⢟⣵⢿⡇⣻⡿⣇⠀⠀⢀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠲⣤⣀⠀⠀⠀⠀⠀⠀⠀⢠⣠⢤⡀⠀⠤⠀⠀⠐⠀⠐⡐⣤⣿⣂⣿⠿⣷⠿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢿⣻⢿⣿⢯⣾⣿⣿⣷⣿⢗⡙⢃⣷⣾⠀⡆⢀⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠇⠀⠑⠆⠀⠀⠀⠀⠲⠌⠉⠁⠁⠀⠀⢠⡀⢤⣐⣈⣿⣿⣿⣿⣿⣿⣿⠦⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⣳⢯⣿⣿⢏⣾⣿⣿⣿⣾⣼⡿⠁⡿⠏⢻⡸⣇⣶⣤⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⢤⣀⣀⣀⠀⣐⣶⣾⣹⣯⣷⣚⠿⣷⣿⣿⣿⣿⡟⣿⠇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢸⠇⣾⣿⣿⣿⣿⣿⣿⣿⣿⡟⣁⣼⠟⣐⣬⡷⣠⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠐⢰⣤⣴⣶⣶⠾⣷⣦⣽⡿⢩⣌⠻⣿⣷⣯⣟⡿⣿⣿⣿⣿⣿⣿⠇⣿⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢀⡟⢀⣼⣿⣿⣿⣿⣿⣿⡿⣋⣴⠟⣡⣶⣿⣿⣿⣿⣿⡇⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⠉⠿⣿⣷⣹⣿⡷⣿⣦⣻⣿⣿⣿⣿⣿⣿⣾⣿⣿⣿⣿⡿⡏⣯⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
// ⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⢘⡇⠸⣿⢋⣿⠟⠋⢁⡿⢠⠛⠠⠌⠉⣿⡿⣿⣿⡿⣿⠃⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠈⢿⣿⣷⢿⣿⣿⣿⣿⡟⠿⣿⣿⣿⣿⣿⣿⣿⣿⣿⢷⣧⣼⡀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀⠀
self.importScripts('config.js');

class BrowseChatService {
  constructor() {
    this.apiKey = CONFIG.API_KEY;
    this.messages = [];
    this.cache = new Map();
    this.setup();
  }

  // initialization + message hangle

  async setup() {
    chrome.runtime.onMessage.addListener(this.handleMsg.bind(this));
    

    try {
      const result = await chrome.storage.local.get(['chatHistory']);
      if (result.chatHistory) this.messages = result.chatHistory;
    } catch (error) {}
  }

  handleMsg(request, sender, sendResponse) {
    const { action } = request;
    
    if (action === 'checkApiKey') {
      sendResponse({ hasApiKey: this.apiKey && this.apiKey !== 'YOUR_OPENAI_API_KEY_HERE' });
      return false;
    }
    
    if (action === 'getChatHistory') {
      sendResponse({ chatHistory: this.messages });
      return false;
    }

    if (action === 'clearHistory') {
      this.clearHistory();
      sendResponse({ success: true });
      return false;
    }

    if (action === 'storePageContent') {
      this.storeContent(request.content);
      sendResponse({ success: true });
      return false;
    }
    
    // async msg handle
    this.handleAsync(request, sendResponse);
    return true;
  }

  async handleAsync(request, sendResponse) {
    try {
      const { action, query } = request;
      
      if (action === 'chatQuery') {
        const answer = await this.processQuery(query);
        sendResponse(answer);
      } else {
        sendResponse({ error: 'Unknown action' });
      }
    } catch (error) {
      sendResponse({ error: error.message });
    }
  }

  // chat storage --> done

  async clearHistory() {
    this.messages = [];
    await chrome.storage.local.set({ chatHistory: [] });
  }

  async saveHistory() {
    // for now 20 messages cuz bloat, maybe change later?
    const trimmedHistory = this.messages.slice(-20);
    await chrome.storage.local.set({ chatHistory: trimmedHistory });
    this.messages = trimmedHistory;
  }

  storeContent(content) {
    if (content?.url) {
      const urlKey = this.makeKey(content.url);
      this.cache.set(urlKey, content);
      
      // prevent large cache --> done
      if (this.cache.size > 100) {
        const firstKey = this.cache.keys().next().value;
        this.cache.delete(firstKey);
      }
    }
  }

  makeKey(url) {
    try {
      return btoa(url).replace(/[^a-zA-Z0-9]/g, '').substring(0, 50);
    } catch (e) {
      return url.replace(/[^a-zA-Z0-9]/g, '').substring(0, 50);
    }
  }

 // chrome browser api search --> done
  async findPages(query, maxResults = 500) {
    const timeRange = this.parseTime(query);
    const searchTerms = this.cleanQuery(query);
    
    let items = await chrome.history.search({
      text: searchTerms,
      maxResults,
      startTime: timeRange.start,
      endTime: timeRange.end
    });

    // kinda jank word finder incase chrome api dont work :(
    if (items.length === 0 && searchTerms) {
      const words = searchTerms.split(/\s+/).filter(w => w.length > 2);
      const results = new Set();
      
      for (const word of words) {
        const wordResults = await chrome.history.search({
          text: word,
          maxResults: 200,
          startTime: timeRange.start,
          endTime: timeRange.end
        });
        wordResults.forEach(item => results.add(JSON.stringify(item)));
      }
      
      items = Array.from(results).map(item => JSON.parse(item));
    }

    // time query
    if (items.length === 0 && timeRange.isTimeOnly) {
      items = await chrome.history.search({
        text: '',
        maxResults,
        startTime: timeRange.start,
        endTime: timeRange.end
      });
    }

    return this.rankResults(items, query);
  }

  // probably the most inefficient way to do a time related query but its 1 am and im too far in
  parseTime(query) {
    const now = Date.now();
    const queryLower = query.toLowerCase();
    
    const timePatterns = [
      { regex: /last (\d+) hours?/i, unit: 'hours' },
      { regex: /today/i, type: 'today' },
      { regex: /yesterday/i, type: 'yesterday' },
      { regex: /last week/i, days: 7 },
      { regex: /last month/i, days: 30 },
      { regex: /last (\d+) days?/i, unit: 'days' },
      { regex: /recent/i, hours: 24 }
    ];

    for (const pattern of timePatterns) {
      const match = queryLower.match(pattern.regex);
      if (match) {
        let start, end = now;
        
        if (pattern.type === 'today') {
          const today = new Date();
          today.setHours(0, 0, 0, 0);
          start = today.getTime();
        } else if (pattern.type === 'yesterday') {
          const yesterday = new Date();
          yesterday.setDate(yesterday.getDate() - 1);
          yesterday.setHours(0, 0, 0, 0);
          start = yesterday.getTime();
          end = start + (24 * 60 * 60 * 1000);
        } else if (pattern.unit === 'hours') {
          const hours = match[1] ? parseInt(match[1]) : pattern.hours || 1;
          start = now - (hours * 60 * 60 * 1000);
        } else if (pattern.unit === 'days') {
          const days = match[1] ? parseInt(match[1]) : pattern.days || 1;
          start = now - (days * 24 * 60 * 60 * 1000);
        } else if (pattern.days) {
          start = now - (pattern.days * 24 * 60 * 60 * 1000);
        } else if (pattern.hours) {
          start = now - (pattern.hours * 60 * 60 * 1000);
        }
        
        return { start, end, isTimeOnly: true };
      }
    }
    
    return {
      start: now - (90 * 24 * 60 * 60 * 1000),
      end: now,
      isTimeOnly: false
    };
  }

  cleanQuery(query) {
    // remove time-related words to get clean search terms
    const timeWords = /\b(last|past|in|the|hour|hours|day|days|week|weeks|month|months|today|yesterday|recent|recently|ago|within|during|since|minute|minutes)\b/gi;
    const cleanQuery = query.replace(timeWords, ' ').replace(/\s+/g, ' ').trim();
    return cleanQuery.length < 3 ? '' : cleanQuery;
  }

  // manual scoring cuz i hate myself
  rankResults(items, query) {
    const queryWords = query.toLowerCase().split(/\s+/).filter(w => w.length > 2);
    
    const scored = items.map(item => {
      const title = (item.title || '').toLowerCase();
      const url = (item.url || '').toLowerCase();
      

      const titleScore = this.getRelevance(queryWords, title) * 0.7;
      const urlScore = this.getRelevance(queryWords, url) * 0.3;
      
      // recency bonus
      const daysSince = (Date.now() - item.lastVisitTime) / (1000 * 60 * 60 * 24);
      const recencyScore = 0.2 * Math.max(0, 1 - (daysSince / 30));
      
      // visit frequency bonus
      const visitScore = item.visitCount ? 
        Math.min(Math.log(item.visitCount) / 10, 0.2) : 0;
      
      const totalScore = titleScore + urlScore + recencyScore + visitScore;
      
      return {
        ...item,
        score: totalScore,
        lastVisitFormatted: new Date(item.lastVisitTime).toLocaleString()
      };
    });

    return scored
      .filter(item => item.score > 0.05)
      .sort((a, b) => b.score - a.score)
      .slice(0, 10);
  }

  getRelevance(queryWords, text) {
    if (!text || queryWords.length === 0) return 0;

    let score = 0;
    let matches = 0;

    queryWords.forEach(word => {
      const regex = new RegExp(`\\b${word.replace(/[.*+?^${}()|[\]\\]/g, '\\$&')}\\b`, 'gi');
      const exactMatches = (text.match(regex) || []).length;
      
      if (exactMatches > 0) {
        matches++;
        score += Math.min(exactMatches * 0.3, 1.0);
      } else if (text.includes(word)) {
        score += 0.15;
      }
    });

    // matching words bonus
    const coverage = matches / queryWords.length;
    score += coverage * 0.4;

    return Math.min(score, 1.0);
  }

  // content scrape --> done

  async getContent(url) {
    const urlKey = this.makeKey(url);
    
    if (this.cache.has(urlKey)) {
      return this.cache.get(urlKey);
    }
    
    const storageKey = `content_${urlKey}`;
    const stored = await chrome.storage.local.get([storageKey]);
    
    if (stored[storageKey]) {
      const content = stored[storageKey];
      this.cache.set(urlKey, content);
      return content;
    }
    
    // open tab extraction
    const tabs = await chrome.tabs.query({});
    const matchingTab = tabs.find(tab => 
      tab.url === url || (tab.url && url && new URL(tab.url).origin === new URL(url).origin)
    );
    
    if (matchingTab && matchingTab.url !== 'chrome://newtab/') {
      try {
        const results = await chrome.scripting.executeScript({
          target: { tabId: matchingTab.id },
          function: this.extractContent
        });
        
        if (results?.[0]?.result?.text?.length > 50) {
          const content = results[0].result;
          this.storeContent(content);
          return content;
        }
      } catch (error) {}
    }
    
    // if i cant get content this is my excuse :)
    return {
      title: 'Content not captured',
      url,
      text: `Content from ${url} was not captured by the extension.`,
      summary: `Content from ${new URL(url).hostname} not available`,
      timestamp: Date.now(),
      wordCount: 0,
      captured: false
    };
  }

  // less apparently is not more when i write code
  extractContent() {
    const url = window.location.href;
    const title = document.title || 'Untitled';

    const contentStrategies = [
      // semantic html element search
      () => {
        const semanticSelectors = ['article', 'main', '[role="main"]', 'section[class*="content"]'];
        for (const selector of semanticSelectors) {
          const element = document.querySelector(selector);
          if (element && element.textContent.length > 300) {
            return this.processElement(element);
          }
        }
        return null;
      },
      
      // if that dosent work
      () => {
        const contentSelectors = [
          '.post-content', '.entry-content', '.article-body', '.story-body',
          '.content', '.post-body', '#content', '.article-text', '.page-content',
          '.blog-post', '.news-article', '[class*="article"]', '[class*="post"]'
        ];
        
        for (const selector of contentSelectors) {
          const element = document.querySelector(selector);
          if (element && element.textContent.length > 300) {
            return this.processElement(element);
          }
        }
        return null;
      },
      
      // if that dosent work find element with most text content LOL
      () => {
        const candidates = document.querySelectorAll('div, section, article, p');
        let bestElement = null;
        let bestScore = 0;
        
        for (const element of candidates) {
          const className = (element.className || '').toLowerCase();
          const id = (element.id || '').toLowerCase();
          
          if (this.isUnwanted(className, id)) continue;
          
          const textLength = element.textContent.length;
          const childDivs = element.querySelectorAll('div').length;
          const paragraphs = element.querySelectorAll('p').length;
          
          const score = textLength + (paragraphs * 50) - (childDivs * 10);
          
          if (score > bestScore && textLength > 200) {
            bestScore = score;
            bestElement = element;
          }
        }
        
        return bestElement ? this.processElement(bestElement) : null;
      }
    ];
    
    let extractedContent = null;
    for (const strategy of contentStrategies) {
      extractedContent = strategy.call(this);
      if (extractedContent && extractedContent.length > 500) break;
    }
    
    // if nothin else works
    if (!extractedContent || extractedContent.length < 200) {
      extractedContent = this.processElement(document.body);
    }
    
    const cleanText = this.cleanText(extractedContent);
    const summary = this.makeSummary(cleanText);
    
    return {
      url,
      title,
      text: cleanText,
      summary,
      timestamp: Date.now(),
      wordCount: cleanText.split(/\s+/).filter(w => w.length > 0).length,
      metadata: { extractionMethod: 'advanced', contentLength: cleanText.length }
    };
  }

  processElement(element) {
    if (!element) return '';
    
    const clone = element.cloneNode(true);
    
    // cleanup
    const unwantedSelectors = [
      'script', 'style', 'nav', 'header', 'footer', 'aside',
      '.nav', '.menu', '.sidebar', '.advertisement', '.ad', '.ads',
      '.social-share', '.comments', '.related-posts', '.newsletter',
      '.popup', '.modal', '.overlay', '[class*="ad-"]', '[id*="ad-"]',
      'button', 'form', '.cookie-banner', '.gdpr'
    ];
    
    unwantedSelectors.forEach(selector => {
      const elements = clone.querySelectorAll(selector);
      elements.forEach(el => el.remove());
    });
    
    return clone.textContent || clone.innerText || '';
  }

  isUnwanted(className, id) {
    const unwantedPatterns = [
      'nav', 'menu', 'sidebar', 'footer', 'header', 'ad', 'advertisement',
      'social', 'share', 'comment', 'related', 'newsletter', 'popup'
    ];
    
    const text = `${className} ${id}`.toLowerCase();
    return unwantedPatterns.some(pattern => text.includes(pattern));
  }

  cleanText(text) {
    if (!text) return '';
    
    return text
      .replace(/\s+/g, ' ')
      .replace(/\n\s*\n/g, '\n')
      .replace(/[^\w\s\.\,\!\?\:\;\-\(\)]/g, ' ')
      .trim()
      .substring(0, 8000);
  }

  makeSummary(text) {
    if (!text || text.length < 50) return text;
    
    const sentences = text.split(/[.!?]+/).filter(s => s.trim().length > 20);
    let summary = '';
    let wordCount = 0;
    
    for (const sentence of sentences.slice(0, 5)) {
      const sentenceWords = sentence.trim().split(/\s+/).length;
      if (wordCount + sentenceWords > 100) break;
      
      summary += sentence.trim() + '. ';
      wordCount += sentenceWords;
    }
    
    return summary.trim() || text.substring(0, 200) + '...';
  }

  // chatgpt save me --> done

  async processQuery(query) {
 
    this.messages.push({
      role: 'user',
      content: query,
      timestamp: Date.now()
    });
    
    const historyResults = await this.findPages(query, 50);
    
    if (historyResults.length === 0) {
      const response = {
        answer: "I couldn't find any relevant pages in your browsing history for that query.",
        sources: []
      };

      this.messages.push({
        role: 'assistant',
        content: response.answer,
        timestamp: Date.now()
      });

      await this.saveHistory();
      return response;
    }

    const selectedSources = await this.chooseBest(query, historyResults);
    
    // get content
    const contextResults = [];
    for (const item of selectedSources) {
      const pageContent = await this.getContent(item.url);
      contextResults.push({
        title: item.title || 'Untitled',
        url: item.url,
        lastVisit: new Date(item.lastVisitTime).toLocaleDateString(),
        score: item.aiRelevanceScore || item.score,
        content: pageContent.text,
        summary: pageContent.summary,
        aiReason: item.aiReason
      });
    }

    const messages = [
      {
        role: 'system',
        content: `You are a helpful assistant that answers questions based on the user's browsing history. Use the provided sources to give detailed, accurate answers and cite your sources.`
      },

      ...this.messages.slice(-11, -1).map(msg => ({
        role: msg.role,
        content: msg.content
      })),
      {
        role: 'user',
        content: `Question: ${query}

Relevant pages from browsing history:

${contextResults.map((c, i) => 
          `${i + 1}. ${c.title}
URL: ${c.url}
Last Visited: ${c.lastVisit}
Content: ${c.content}
---`
        ).join('\n')}`
      }
    ];

    // call openai api with proper error handling
    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages,
          max_tokens: 800,
          temperature: 0.3
        })
      });
      
      if (!response.ok) {
        const errorText = await response.text();
        console.error('OpenAI API Error:', response.status, errorText);
        throw new Error(`OpenAI API error: ${response.status} - ${errorText}`);
      }
      
      const data = await response.json();
      
      if (!data.choices || !data.choices[0] || !data.choices[0].message) {
        throw new Error('Invalid response format from OpenAI API');
      }
      
      const finalResponse = {
        answer: data.choices[0].message.content,
        sources: contextResults.map(c => ({ 
          title: c.title, 
          url: c.url, 
          lastVisit: c.lastVisit,
          relevanceScore: c.score,
          summary: c.summary,
          aiReason: c.aiReason
        }))
      };

      // save history
      this.messages.push({
        role: 'assistant',
        content: finalResponse.answer,
        timestamp: Date.now(),
        sources: finalResponse.sources
      });

      await this.saveHistory();
      return finalResponse;
      
    } catch (error) {
      console.error('Error in processQuery:', error);
      
      // Provide a more detailed error message
      let errorMessage = error.message;
      if (error.message.includes('401')) {
        errorMessage = 'Authentication failed. Please check your OpenAI API key.';
      } else if (error.message.includes('429')) {
        errorMessage = 'Rate limit exceeded. Please try again later.';
      } else if (error.message.includes('500')) {
        errorMessage = 'OpenAI service error. Please try again later.';
      }
      
      throw new Error(errorMessage);
    }
  }

  async getRecentPages(query, daysBack = 30, maxResults = 50) {
    const now = Date.now();
    const startTime = now - (daysBack * 24 * 60 * 60 * 1000);

    let items = await chrome.history.search({
      text: '',
      maxResults,
      startTime,
      endTime: now
    });

    // score items by recency and visit frequency
    const scored = items.map(item => {
      const daysSince = (now - item.lastVisitTime) / (1000 * 60 * 60 * 24);
      const recencyScore = Math.max(0, 1 - (daysSince / daysBack));
      const visitScore = item.visitCount ? Math.min(Math.log(item.visitCount) / 10, 0.3) : 0;
      
      return {
        ...item,
        score: recencyScore + visitScore,
        lastVisitFormatted: new Date(item.lastVisitTime).toLocaleString()
      };
    });

    return scored
      .sort((a, b) => b.score - a.score)
      .slice(0, Math.min(maxResults, 30));
  }

  async chooseBest(query, historyResults, maxSources = 5) {

    const sourcesList = historyResults.map((item, index) => 
      `${index + 1}. Title: "${item.title || 'Untitled'}"
   URL: ${item.url}
   Last Visit: ${item.lastVisitFormatted}
   Visit Count: ${item.visitCount || 1}`
    ).join('\n\n');

    const selectionPrompt = {
      role: 'user',
      content: `Select the ${maxSources} most relevant web pages from my browsing history to answer: "${query}"

Available pages:

${sourcesList}

Respond in JSON format:
{
  "selected_sources": [
    {
      "page_number": 1,
      "relevance_score": 8,
      "reason": "This page contains information about..."
    }
  ]
}`
    };

    try {
      const response = await fetch('https://api.openai.com/v1/chat/completions', {
        method: 'POST',
        headers: {
          'Authorization': `Bearer ${this.apiKey}`,
          'Content-Type': 'application/json'
        },
        body: JSON.stringify({
          model: 'gpt-4o-mini',
          messages: [
            {
              role: 'system',
              content: 'You select the most relevant sources from browsing history. Always respond with valid JSON.'
            },
            selectionPrompt
          ],
          max_tokens: 1000,
          temperature: 0.1
        })
      });

      if (!response.ok) {
        console.warn('Source selection API call failed, using fallback');
        return historyResults.slice(0, maxSources);
      }

      const data = await response.json();
      let aiResponse = data.choices[0].message.content;
      aiResponse = aiResponse.replace(/```json\s*/g, '').replace(/```\s*$/g, '').trim();
      
      const selection = JSON.parse(aiResponse);
      const selectedSources = [];
      
      for (const selected of selection.selected_sources) {
        const pageIndex = selected.page_number - 1;
        if (pageIndex >= 0 && pageIndex < historyResults.length) {
          const source = historyResults[pageIndex];
          selectedSources.push({
            ...source,
            aiRelevanceScore: selected.relevance_score,
            aiReason: selected.reason
          });
        }
      }
      
      return selectedSources.length > 0 ? selectedSources : historyResults.slice(0, maxSources);
      
    } catch (error) {
      console.warn('Error in chooseBest, using fallback:', error);
      // fallback to top results
      return historyResults.slice(0, maxSources);
    }
  }
}

// initialize the service
new BrowseChatService();